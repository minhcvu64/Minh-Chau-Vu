# Introduction to Dart programming language
## Organization: OpenKnect

## Member: Duy Pham

**Tutorial Playlist: https://www.youtube.com/playlist?list=PL6yRaaP0WPkVLSOchfoIA0ZXySz4eSYV2**

**Chapters Summary**
|   | Chapter           | Summary  |
|:--|:------------------|:---------|
|1  | Variables and Data Types         | Dart allows inferred type: var n = 3; however, I prefer to specify the data type explicitly i.e: String name = 'Duy';. There are immutable variables: const and final: both do not allow assigning new values to the variable, but final enables changing the internal content of the variable like updating elements in a list. This is not allowed for const.  |
|2  | Operators                  | This chaper is quite simple and familiar if we have learnt another programming language before. There is nothing special or different in Dart.  |
|3  | Optionals      | Optional on a type allows a variable of that type can be null. Null-aware operator ?? helps make sure we get a non-null value. This operator can combine multiple times i.e: name1 ?? name2 ?? name3 ?? 'Duy'. To access a property or method of a optional variable, we should put a ? before . , to return null if we are trying to access a null.  |  
|4  | Late Variables | For late variable, we must initialize it when defining, most of the time it is initialized to a result returned from a function or an operation. Because the purpose of late variable is excuting the assignment including the method used to assign, at the first time the variable is used. A late variable maybe dependent on another late variable, which makes the code not understandable, I do not prefer it. Besides, we should not initialize a late property of class in its constructor, but at the late property's declaration. Otherwise, the late property will be implicitly used when creating an instance of the class, so it has been initialzed at that time rather the first time we actually call it. |
|5  | Functions | Functions in Dart are not many different. Dart supports more different types of parameters such as named parameters. Named parameters are included in { } (order does not matter), and they must be either have default value or set required. Dart also supports arrow functions like JavaScript and Java, and passing and returning a function are allowed as well.    |
|6  | Control Flow  | If-else, loops, and switch statements are the same with popular programming languages such as C++, Java and JavaScript.   |
|7  | Collections  | List, Set, Map and Iterable are also supported in Dart. The sytax is similar to Java, Python and JavaScript. Like JavaScript, Dart has spread operator ... for collections, which is so useful. Besides, we use cascading operator .. to perform a bunch of continuous methods on the same object i.e: mylist..removeAll([null])..add('open')..add('knect'). Not just JavaScript style, Dart also has collection comprehensions like Python, but the syntax is different.  |
|8  | Enumerations  | Like other popular programming language, Dart also supports Enum for representing data type with sub-cases. Its syntax is also similar to other languages': enum EmployeeType { teacher, engineer, doctor;  double getTitle() { ... } }, which can include functions inside, or can be added later by extensions. However, unlike other languages, enhanced enumerations in Dart are not flexible as we must hardcode the properties for each sub-case of the enum, and the properties must also be the same within all sub-cases. This makes me rather use Class than Enhanced Enum. So I hope this drawback would be updated in later versions.     |
|9  | Classes  | Classes in Dart have variants of constructors that I feel unnecessary, that makes it just more complex and unreadable. I would like choose one of them: Person({required this.name, requried this.age}). Sub-classes in Dart has similar idea and sytax with other languages', one interesting thing for me is runtimeType, which helps determine the class type simply. Private properties are indicated by an underscore at the beginning of the property name. Besides, setters and gettets have unique sytax so we should notice it.  |
|10  | Mixin & Mirror   | Mixin is basically a class, but it cannot be instantiated. Its properties and methods can be utilized by other classes without extending or inheritance. Use keyword Mixin to create a mixin instead of keyword Class. Then we use keyword with to allow another class to use the mixin instead of keyword extend or implement. So using mixin is a way to reuse code and write code clean. For mirror, through the tutorial chapter, I actually did not get any advantage or usecase that I need to use it. The example on mirror is not practical, but even complex. So I think that I should watch a longer video for this new topic.  |
|11  | Custom Operators  | Dart also supports custom and overloading operators using extensions on (generic) data types  |
|12  | Extensions   | Extensions are a really helpful feature of Dart, which allows us to create any method for any (generic) data type. Then, we can apply the functions on variables associated with the data type within the program.   |
|13  | Generics    | Generics are very helpful, which allows us to work on generic data types including a range of data types rather than only one as usual. With a generic type T, we can use it with any defined type, and we can even constrain it, i.e: T extends num, to works on numeric only. Besides, we have type dynamic, that allows any type, the variable change its type over time with the program, suitable for json type:  typedef JSON<String, dynamic> = Map<String, dynamic>.   |
|14  | Exceptions & Errors  | Dart has almost similar error handlers as other popular languages'. try-catch block has always been the most frequently-used way for me. In this chapter, I got to know stack trace as the second parameter in the catch(), which may be helpful for some cases.  |
|15  | Asynchronous Programming  | Dart also supports Future as a result of an asynchronous computation, and if the result has multiple states, producing values continuously, that is a Stream. We use keyword async to allow a function to have async operations, and use keyword await to wait for an async operation finish (either completed or uncompleted). For Stream, we use keyword async* to allow function to yeild a value into a stream. We can consume a stream by either "await for" or listen(). Reactive programming also provides various different methods to process a stream, and one of them is map() used mostly in the video. This method maps each item in the stream into different item, which creates another stream with different values, but the same number of items.   |

## Conclusion
Dart is a programming language that is not hard to learn because most syntax is similar to other languages'. Although it introduces new concepts/syntax like late variables, function parameters, variants of constructors, ..., we are programmer. So we should use the most comfortable way to code, just use familiar syntax suitable with your own coding style, that is enough. The most important thing is still logic.